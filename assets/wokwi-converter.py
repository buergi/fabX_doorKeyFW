#!/usr/bin/python

import sys
import re
import numpy as np

def reverse_bits(byte):
    """
    Reverse the order of bits in a byte.

    :param byte: An integer representing a byte (0-255)
    :return: The byte with bits in reverse order
    """
    if byte < 0 or byte > 255:
        raise ValueError("Input must be a byte (0-255).")

    reversed_byte = 0
    for i in range(8):
        if byte & (1 << i):
            reversed_byte |= (1 << (7 - i))

    return reversed_byte

def crop(array, width, height):
    num_images = len(array)
    pixels_per_value = 8

    # Convert the array to a numpy array for easier manipulation
    array = np.array(array)

    # Initialize the crop amounts
    top_crop = height
    bottom_crop = height
    left_crop = width // pixels_per_value
    right_crop = width // pixels_per_value

    # Determine the maximum crop for each image
    for image in array:
        image_2d = image.reshape(height, width // pixels_per_value)

        # Find top crop
        for i in range(height):
            if not np.all(image_2d[i] == 0):
                top_crop = min(top_crop, i)
                break

        # Find bottom crop
        for i in range(height-1, -1, -1):
            if not np.all(image_2d[i] == 0):
                bottom_crop = min(bottom_crop, height - i - 1)
                break

        # Find left crop
        for i in range(width // pixels_per_value):
            if not np.all(image_2d[:, i] == 0):
                left_crop = min(left_crop, i)
                break

        # Find right crop
        for i in range(width // pixels_per_value - 1, -1, -1):
            if not np.all(image_2d[:, i] == 0):
                right_crop = min(right_crop, width // pixels_per_value - i - 1)
                break

    # Apply the crop to each image
    cropped_array = []
    for image in array:
        image_2d = image.reshape(height, width // pixels_per_value)
        cropped_image_2d = image_2d[top_crop:height-bottom_crop, left_crop:width//pixels_per_value-right_crop]
        cropped_array.append(cropped_image_2d.flatten())

    # Update width and height
    new_width = (width // pixels_per_value - left_crop - right_crop) * pixels_per_value
    new_height = height - top_crop - bottom_crop

    return np.array(cropped_array), new_width, new_height

def main(argc, argv):
    RE_NUMBER = re.compile(r".*\(([0-9]+)\).*")
    a = []
    if argc<3:
        print(f"usage: {argv[0]} path name")
        print("  Tool converts animations generated by https://animator.wokwi.com/ to XBM format.")
        print("  it reverses the bit order and crops the animation.")
        print("    path: path to code file of generated by Wokwi Animator")
        print("    name: name of the variables in the generated code ")
        return 0
    path = argv[1]
    name = argv[2]
    height = 0
    width = 0
    with open(path,"r") as f:
        for line in f:
            if line.startswith("#define FRAME_DELAY"):
                print(line.strip().replace('FRAME_',f"{name.upper()}_"))
            if line.startswith("#define FRAME_HEIGHT"):
                m = RE_NUMBER.match(line)
                if m:
                    height = int(m.group(1))
            if line.startswith("#define FRAME_WIDTH"):
                m = RE_NUMBER.match(line)
                if m:
                    width = int(m.group(1))
            if line.startswith("  {"):
                dat = [int(x) for x in line.strip(' \t\n\r{},').split(',')]
                a.append(dat)
    a, width, height = crop(a, width, height)
    print(f'#define {name.upper()}_HEIGHT ({height})')
    print(f'#define {name.upper()}_WIDTH ({width})')
    print(f'#define {name.upper()}_COUNT (sizeof({name.lower()}_frames) / sizeof({name.lower()}_frames[0]))')
    print(f'const byte PROGMEM {name.lower()}_frames[][{len(dat)}] = {{')
    for r in a:
      l = [str(reverse_bits(i)) for i in r]
      print('  {'+(', '.join(l))+'},')
    print('};')
    return 0

if __name__ == '__main__':
    sys.exit(main( argc=len(sys.argv), argv=sys.argv ))

